# HTTP 스터디 정리

> [!NOTE]
HTTP를 학습하며 스터디 중 논의한 내용을 정리한 문서입니다.
> 

<br>

# 📌 HTTP의 등장배경

HTTP가 등장하기 이전에는 웹 애플리케이션별로 통신 메세지 규약이 상이했다.

1. **문서 공유의 어려움**
    - 과거에는 각 컴퓨터에 저장된 문서에 접근하려면 FTP나 특정 프로토콜(예: gopher)을 써야 했음
    - 이들은 사용법이 복잡하고, 링크를 통한 문서 간 이동이 어려웠음
2. **이질적인 시스템 간의 정보 접근 문제**
    - 운영체제나 컴퓨터마다 문서 포맷과 접근 방식이 달라, 한 시스템의 정보를 다른 시스템에서 쉽게 열람하기 어려웠음
3. **하이퍼링크 기능의 부재**
    - 사용자는 다른 문서로 ‘이동’하려면 경로를 복사해 붙여넣거나 수동으로 입력해야 했고, 문서 간의 자연스러운 이동이 불가했음.
4. **분산 환경에서의 표준화 부족**
    - 여러 서버와 클라이언트가 통신할 수 있는 **공통된 규칙(프로토콜)**이 부족해 확장성과 호환성이 떨어졌음.

이 메세지 규약을 통합한것이 HTTP로, 1991년 0.9버전의 프로토타입을 시작으로 현재 3까지 이르렀다.

단순한 문서 연결을 위한 프로토콜이었으나, **분산 환경에서의 송수신 규약 표준화**로 대 통신의 시대를 열었다.

<br>

# 📌 HTTP의 주요 특징

**1) 비연결성** → 요청 후 연결을 끊음(단 Keep-Alive로 유지 가능)

*❓왜 이렇게 설계됐을까?*

1. 서버 자원 절약 → 연결을 유지하지 않음으로써, 많은 사용자를 동시에 처리 가능
2. 낮은 부하 → 상태를 유지할 필요가 없으므로 서버 부담 감소
3. 단순하고 효율적 → 초기 인터넷은 리소스가 적었고, 매 요청마다 새로 연결하는 게 효율적이었음

**2)무상태성** → 이전 요청 정보를 기억하지 않음

*❓왜 이렇게 설계됐을까?*

1. 간단한 구조 → 상태를 유지하지 않아서 프로토콜 자체가 단순함
2. 분산 시스템에 적합 → 상태 공유 없이도 여러 서버에 요청을 분산 가능(로드 밸런싱에 유리)
3. 확장성 → 상태를 저장하지 않아도 되므로 수많은 요청을 동시에 처리 가능

<br>

# 📌 HTTP의 전송 방식

![image](https://github.com/user-attachments/assets/0a49b1a4-c027-49f4-a42b-87fc068fe7ed)

HTTP는 어플리케이션 계층의 프로토콜로 신뢰가능한 전송 계층 프로토콜(TCP) 위에서 동작합니다.

보안이 강화된 버전인 HTTPS(HTTP over TLS)는 TLS(SSL)를 통해 데이터를 암호화하여 전송합니다.

<br>

# 📌 HTTP 메세지의 구성

![image (1)](https://github.com/user-attachments/assets/e13aad03-2842-4aa0-acc5-3de286270150)

HTTP는 확장을 염두에 두어, 다음이 가능하다. (사실 더 많다)

- 애플리케이션 간 정의한 커스텀 메서드를 사용할 수 있다.
- 애플리케이션 간 정의한 커스텀 헤더를 사용할 수 있다
- 사유 구절은 오로지 인간을 위한 평문으로, 상태코드에 적합한 아무 구절도 괜찮다.
- 시작줄-헤더, 헤더-헤더는 일반 줄바꿈으로, 헤더-본문은 캐리지-리턴으로 구분한다.

그래서 무한으로 붙이는게 가능하다.(…) (사실 아니다. TCP세그먼트는 최대 용량 제한이 존재한다.)

<br>

# 📌 HTTP의 버전

- HTTP/0.9 (1991년)
- HTTP/1.0 (1996년)
- HTTP/1.1 (1997년) → 가장 많이 사용
- HTTP/2.0 (2015년) → HTTP 1.1의 성능 개선 및 확장
- HTTP/3.0 (진행 중)

<br>

## 1️⃣ HTTP/0.9

- 단일 라인으로 GET 요청만 가능
- 응답은 HTML만 포함

HTTP 헤더도 없고, HTML 파일만 전송 가능했던 것이 특징!

```swift
/* 요청 */
GET /mypage.html

/* 응답 */
<HTML>
A very simple HTML page
</HTML>
```

<br>

## 2️⃣ HTTP/1.0

- 요청/응답에 헤더 추가
- 다양한 HTTP 메서드 지원: GET, POST, HEAD 등
- 상태 코드, 콘텐츠 유형 등 메타 정보 사용 가능
- `Content-Type` 도입으로 HTML 이외의 문서 전송 기능이 가능해짐

**한계** → 요청마다 TCP 연결을 새로 진행, 한번에 하나의 요청과 응답만 처리 가능

```swift
/* 요청 */
GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

/* 응답 */
200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
<HTML>
A page with an image
  <IMG SRC="/myimage.gif">
</HTML>
```

<br>

## 3️⃣ HTTP/1.1

- 지속 연결(persistent connection)을 기본으로 지원
    - 지정한 Time-Out 동안 커넥션을 닫지 않는 방법을 통해 커넥션의 사용성이 높아짐
- 파이프라이닝(Pipe-Lining) 지원(하지만 실무에서는 거의 사용되지 않음)
    - 앞 요청의 응답을 기다리지 않고 여러 요청을 연속적으로 보낸 뒤 순서에 맞춰 응답을 받음
    - 하나의 커넥션에 여러 요청이 들어 있을 뿐, 동시에 요청을 처리해 응답으로 보내주는 것은 아님

**1.1에서의 개선점** → 여러 요청을 한 연결에서 처리 가능

**한계** → Head-Of-Line Blocking(HOLB) 문제(하나의 요청이 지연되면 이후 요청도 지연됨)

![image (5)](https://github.com/user-attachments/assets/ae228877-0ebb-4389-a511-a10404298a2e)

### 🤔 그렇다면 여러 요청을 어떻게 처리했을까?

➡️ 병렬 TCP 연결 사용

브라우저는 같은 서버에 대해 여러개의 커넥션을 동시에 열어서 리소스를 병렬로 요청함

```swift
연결1: 요청 A → 응답 A
연결2: 요청 B → 응답 B
연결3: 요청 C → 응답 C
...
```

- 장점 → 병렬 요청 가능
- 단점 → 연결이 많아져 자원 소모 증가

### 💥 HTTP 트랜잭션 지연

![image (6)](https://github.com/user-attachments/assets/8c4c08be-6fc0-4c24-b1aa-ebac44a74963)

HTTP는 각개의 메세지가 독립적인데 반해, TCP는 연결 지향적이다.
따라서 HTTP 메세지 하나를 보낼 때 마다, TCP연결을 생성하고 종료함에 따른 오버헤드가 존재한다.
이는 요청-응답의 성능을 저하시키는 주요 요인중에 하나로 꼽힌다.

아래는 이를 개선하기 위한 방법 중 하나인 `HTTP/1.0 keep-alive`와 `HTTP/1.1 지속 커넥션` 의 비교다.

| 구분 | HTTP/1.0 `keep-alive` | HTTP/1.1 지속 커넥션 `Persistent Connection` |
| --- | --- | --- |
| 기본 동작 | 기본은 **비활성 (비지속)**. `Connection: keep-alive` 헤더로 명시해야 지속 연결 가능 | 기본적으로 **지속 연결 활성화 상태** (명시 안 해도 유지됨) |
| 연결 종료 | 기본적으로 각 요청 후 연결 닫음. `Connection: keep-alive` 있으면 연결 유지 | 연결을 명시적으로 닫으려면 `Connection: close` 헤더 필요 |
| 헤더 사용법 | 클라이언트와 서버 모두 명시적으로 `Connection: keep-alive` 헤더를 주고받아야 함 | 지속 연결이 기본이므로 필요 시 `Connection: close`로 종료 요청 |
| 요청 처리 방식 | 한 연결에서 여러 요청을 순차적으로 처리 가능 (직렬 처리) | 한 연결에서 여러 요청을 순차적으로 처리 (직렬), HTTP/2 전에는 멀티플렉싱 없음 |
| 제한사항 | - 연결 유지 시간 및 요청 수 제한은 명시적으로 설정해야 함<br>- 명세가 모호해 구현 차이 존재 | - 연결 유지 기본<br>- 서버나 클라이언트가 `timeout`이나 `max requests`로 제한 가능 |
| 호환성 | HTTP/1.0 클라이언트/서버에서 선택적 지원 | HTTP/1.1에서는 필수 지원 (지속 연결) |
| 실용성 | 널리 쓰이진 않았고, 일부 서버에서만 구현 | HTTP/1.1 표준의 핵심 성능 개선점, 거의 모든 서버/클라이언트에서 기본 지원 |

<br>

## 4️⃣ HTTP/2.0

![image (3)](https://github.com/user-attachments/assets/0af7859c-1e47-454d-b0b1-b9a3dcd809bc)

기존 HTTP 1.X 버전의 성능 향상에 초점을 맞춘 버전임, 표준의 대체가 아닌 확장 (표준 : HTTP/1.1)

양방향 흐름을 의미하는 Stream을 바탕으로 요청과 응답이 교환됨(하나의 연결에 여러 Stream 존재 가능)

- HTTP 메시지 전송 방식의 전환(일반 텍스트 → 이진화된 프레임)
    - 파싱 속도 및 전송 속도 향상, 오류 발생 가능성 낮아짐
- 멀티플렉싱 지원 → 하나의 TCP 연결로 여러 요청/응답 병렬 처리, HOLB 문제 해결
- 서버 푸쉬 → 클라이언트 요청 없이도 서버가 추가적인 자원 전송 가능
- 헤더 압축 → 헤더값 중복 제거로 오버헤드 감소

**한계** →

각 요청을 Stream으로 구분해 병렬적으로 처리하지만, 결국 TCP 고유의 HOLB 문제가 존재함!
서로 다른 Stream이 전송되고 있을 때, 하나의 Stream에서 문제가 생기면 결국 다른 Stream도 해당 문제가 해결될 때 까지 기다리는 현상이 발생하기 때문

<br>

## 5️⃣ HTTP/3.0

Google에서 TCP의 구조적 문제로 성능 향상이 어렵다고 판단하여 UDP 기반을 선택

- QUIC(Quick UDP Internet Connections) 프로토콜 위에서 동작 (UDP 기반)
- TLS 1.3을 내장해 보안 연결을 더욱 빠르게(1-RTT) 설정 (TCP에서는 3-RTT 소요)
- Stream이 독립성을 지녀 하나의 Stream이 지연돼도 다른 스트림엔 영향이 없음(TCP HOLB 문제 해결)

HTTP/3.0은 UDP를 사용하지만, QUIC가 TCP 수준의 모든 기능을 직접 제공(흐름 제어, 혼잡 제어 등)

![image (2)](https://github.com/user-attachments/assets/fbba2ed4-1c1b-4400-93d3-caf764d05474)

![image (4)](https://github.com/user-attachments/assets/087678c5-8b8e-4921-a6d7-db2ca64dcbef)

**한계** → UDP 기반으로 인한 인프라 호환성 문제, 운영체제 수준의 최적화 부족(기존 네트워크 분석 도구로는 QUIC 내부를 분석하기 어려움)
HTTP/3는 미래 지향적이지만, 아직은 ‘전환기’

### ‼️ 모바일 환경에서 HTTP/3.0이 특히 더 유리한 이유

**1. 불안정한 네트워크에서 강함**
모바일 네트워크는 신호가 자주 약해지고 패킷 손실이 생김

HTTP/2는 TCP 기반이라 하나의 스트림에서 패킷 손실이 발생하면 전체 연결이 지연됨
반면 HTTP/3는 QUIC 위에서 작동해서 하나의 스트림이 끊겨도 다른 스트림은 영향 없음, 패킷 손실이 발생해도 빠른 재전송 및 복구 가능

**2.  빠른 연결 수립**
모바일 환경에서는 자주 네트워크가 바뀜 (Wi-Fi ↔ LTE 등)

HTTP/3는 QUIC + TLS 1.3을 함께 사용하여 연결을 더 빠르게 맺음 (1-RTT 연결 수립, 최대 0-RTT 재접속까지 가능)
결과적으로, 페이지 로딩 속도가 개선

**3. 핸드오버 및 IP 변경에 강함**
모바일 환경에서는 사용자가 이동하면 IP가 바뀌고, 기존 TCP 연결은 끊어져버림

QUIC은 연결을 식별할 때 IP포트가 아닌 "Connection ID"를 사용, IP가 바뀌어도 연결을 유지할 수 있음
이는 특히 지하철, 이동 중 영상 시청, 게임 등에 큰 장점

**결론** → 모바일 환경에서는 지연이 크고 연결이 자주 끊기거나 바뀌며 신호가 불안정할 수 있는데,
HTTP/3은 이 모든 문제를 해결하기 위한 기술적 설계를 지니고 있기 때문에 모바일에서 더욱 효율적일 수 있음

<br>

# 📌 HTTP 메소드

![image (7)](https://github.com/user-attachments/assets/ac65b19b-61d9-4a3f-a22f-c728a84ab50f)

**안전 (Safe)** → 호출해도 리소스를 변경하지 않는가?

**멱등 (Idenpotent)** → 몇 번을 호출해도 결과가 동일한가?

**캐시 가능 (Cacheable)** → 응답 결과 리소스를 캐시해서 사용해도 되는가?

<br>

# 📌 HTTP 상태 코드

```swift
1xx (Informational) : 요청이 수신되어 처리중
2xx (Successful) : 요청 정상 처리
3xx (Redirection) : 요청을 완료하려면 추가 행동이 필요
4xx (Client Error) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
5xx (Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함
```

### 주요 상태 코드

200 → OK

201 → Created

202 → Accepted (요청은 접수 됐지만 아직 처리 중)

204 → No Content (처리 됐지만 Response 값은 없음)

400 → Bad Request (요청 잘못됨)

401 → Unauthorized (인증 오류)

403 → Forbidden (권한 없음)

404 → Not Found (요청 리소스를 찾을 수 없음)

500 → Internal Server Error (서버 내부 오류)

503 → Service Unavilable (서비스 이용 불가)
